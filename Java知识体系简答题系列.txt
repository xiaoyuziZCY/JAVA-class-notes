## Java知识体系简答题系列



#### 1、int 和 Integer 有什么区别

- int 是JAVA中基本类型中的一个，占用4个字节，32位
- Integer 是引用类型,包装了基本类型中的int
- int的初始化可以是 int a = 1,而 Integer的初始化可以是 Integer a = 1或者 Integer a = new Integer(1)
- Integer 缓存了-128~127范围的数值在内部的一个数组中，当数值在该范围内时，可以使用==与另外一个Integer进行比较，实际是int类型的比较。但是，既然是包装类，推荐使用equals进行比较。

#### 2、重载和重写的区别

* 重载
  * 重载是在编译时就确定执行哪个方法
  * 重载的方法签名，只有参数类型，参数的个数，参数的顺序参与签名，返回值不参与签名
  * 方法名称一致，参数个数、类型、顺序不一致才称之为重载，判断顺序是：个数>类型>顺序。若参数类型一致，但是顺序不一致，不算重载。
* 重写
  * 方法的重写只适用于具有继承关系的子类和父类中，子类对父类中的方法进行重新实现，称之为重写
  * 重写的方法，只有在运行的时候才能确定具体调用父类或者子类的方法

#### 3、请简述抽象类与接口的区别？

* 抽象类：
  * 抽象类可以没有抽象方法，仅使用abstract修饰符对类进行修饰；但是有抽象方法的类一定要是抽象类
  * 类的集成机制是单继承，一个类只能继承一个类，该类可以是抽象类
  * 抽象类不能通过new进行实例化，只能被声明，不能被实例化
  * 抽象类内部可以定义属性和方法
* 接口：
  * 接口仅仅是一系列的方法的声明。jdk1.8之前没有方法的实现，jdk1.8后可以定义默认的实现。
  * 接口的所有方法，默认访问权限均是public
  * 接口同样不能通过new实例化，只能被声明，不能被实例化
  * 一个类可以实现多个接口
  * 接口内部不能定义private修饰的方法
  * 接口的关键字是interface进行定义

#### 4、请叙述equals和==的区别？

* 在java中，数据类型包括基本数据类型和引用数据类型
  * 基本数据类型存在栈中
  * 引用数据类型存在堆中
* ==既可以用于基本数据类型的比较，也可以用于引用数据类型的比较
  * ==用于基本数据类型的比较时，比较的是基本数据类型的数值的大小
  * ==用于引用数据类型的比较时，比较的是内存地址是否相同。
* equals只能用于比较引用数据类型，该方法是Object类中的一个方法，默认比较的是两个对象的内存地址，开发者可以重写equals方法，实现自定义的比较逻辑。

#### 5、Java语言有哪些特点，请简述？

* 语法简单
* 面向对象（封装、继承、多台）
* 平台无关性（Java虚拟机JVM实现平台无关性）
* 垃圾回收机制（GC实现垃圾回收）
* 异常处理机制
* 支持多线程
* 支持网络编程

#### 6、请总结面向过程和面向对象的区别？

* 面向过程：面向过程是关注程序实现的过程，在业务逻辑实现上按照程序处理的先后顺序进行过程实现，面向过程的程序性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。
* 面向对象：面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。面向对象易维护、易复用、易扩展。

#### 7、请简述面向对象的三大特征，并做简单说明？

面向对象的三大特征是：封装、继承、多态

##### 封装

封装是指将程序中涉及到的业务主体进行抽象，抽象出属性和行为，并将两者封装在一个类Class中，属性用变量定义，行为用方法进行定义，方法可以访问统一个对象中的属性。

##### 继承

继承是描述类之间的一种关系，子类继承父类后，可以自动获得父类的属性特征和行为。同时，子类可以进行更多功能的扩展，还可以重新实现父类的方法。

##### 多态	

程序中引用变量指向的具体类型在编译时无法确定，只有在程序执行时才能确定具体的数据类型，这种设计称之为多态。简单说是父类的引用指向之类的对象。



#### 8、在java中，有final、finally、finalize关键字，请对其进行区分说明？

* final关键字是一种修饰符，可以修饰类、变量、方法。被final修饰的类不能被继承，被final修饰的方法不能被重写，被final修饰的变量值不能被更改，总之final代表修饰类型最终的状态。
* finally是java中的异常处理机制中的关键字，常常出现在try-catch-finally代码块中，代表异常处理后需要执行的代码逻辑。
* finalize是java中超类Object的一个方法，该方法在垃圾回收对象时被调用。若手动调用System.gc()方法，该方法也会被调用。



#### 9、列举出你说知道的超类Object中的方法？

* equals方法：比较两个对象是否相等，默认是==比较地址是否相等。
* toString方法：返回类对象的字符串表现形式。
* getClass方法：返回类对象的类型的方法。
* hashCode方法：返回类对象经哈希计算后的哈希码。
* clone方法：对类对象进行克隆的方法。



#### 10、简述String、StringBuffer、StringBuilder有何区别?

* String的值是不可改变的；StringBuffer和StringBuilder的值是可变的。
* StringBuilder是线程不安全的，执行效率高；StringBuffer是线程安全的，执行效率相对较低。
* String类型的数据每次修改都会生成一个新的String对象，变量指针指向新String对象地址。StringBuffer和StringBuilder每次修改修改的都是同一个对象，不改变对象的引用。
* 单线程应用场景中利用字符串缓冲区操作大量数据选择StringBuilder；多线程应用场景中操作大数据量使用StringBuffer。

##### 11、列举Java开发过程中经常遇到的异常，并说明其属于哪种异常（5个及以上）？

* ClassCastException：类型转换异常，当数据类型进行转换发生错误时会发生的异常。
* ClassNotFoundException：类未找到异常，JVM无法加载到对应包名.类名时会发生该异常。
* ArrayIndexOutOfBoundsException：数组越界异常，通过数组下标访问数组超出范围时发生的异常。
* IOException：I/O异常，读写操作过程中遇到异常时会发生该异常。
* NullPointerException：空指针异常，当引用类型的变量未实例化时调用其中的属性或者方法时，会发生该异常。
* FileNotFoundException: 文件不存在异常，操作文件时如果找不到对应的文件会发生该异常。
* SQLException: 在执行sql操作时如果遇到错误，会发生该异常。



##### 12、请简述OSI七层网络模型具备包含哪些？常见的HTTP协议、FTP协议属于哪一层的通信协议？

按照自下而上的顺序依次是：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。

HTTP协议和FTP协议均属于应用层的通信协议。



#### 13、请简述TCP协议的三次握手过程？

在发起TCP连接前，服务端已经进入监听状态，等待客户端的连接，同时客户端主动打开，准备发起连接。

* 第一次握手：客户端发起连接请求报文（SYN包），客户端进入同步发送状态（SYN_SEND），等待服务端确认。
* 第二次握手：服务端接收到报文，同意连接请求。服务端将确认报文（SYN+ACK包）发出，发送给客户端，服务端进入同步收到状态（SYN_RCVD）。
* 第三次握手：客户端收到服务端的确认连接报文（SYN+ack包），进入到建立连接状态，并向服务端发出确认报文，等待服务端进入到建立连接状态，至此完成三次握手。

三次握手结束后，客户端和服务端建立了连接，开始进行通信。



#### 14、在浏览器地址栏中输入http://www.baidu.com 浏览器显示出网页内容。请解释该过程发生了哪些步骤？

① 首先会进行DNS解析，根据输入的网址url解析到对应的IP服务器地址

② 浏览器向服务器发起TCP链接，进行三次握手

③ 建立TCP连接后，浏览器发起HTTP请求

④ 服务器接收HTTP请求，并处理该请求，处理结束后，返回请求响应给浏览器

⑤ 浏览器接收请求响应，并将响应内容解析渲染成网页效果

⑥ 此次请求结束，浏览器与服务器四次挥手，断开连接。



#### 15、请用自己的话总结说明TCP和UDP的区别？并尝试总结TCP和UDP各自的适用场景？

对别和区别：

* TCP和UDP都是OSI模型中传输层的协议。
* TCP是面向连接的协议，需要客户端和服务端同时在线；UDP是无连接的，客户端和服务端不需要同时在线；
* TCP传输稳定、可靠，传输数据有序；UDP可能会发生数据丢包。
* TCP连接占用资源较多，要求高；UDP所需占用系统资源较少。

适用场景：

* TCP：tcp连接适合于对通信质量要求高的场景，需要保证数据准确传输和送达，比如常见的HTTP协议、HTTPS协议、FTP文件传输协议等均是基于TCP协议而实现的。
* UDP：如果在应用中对通信质量要求不是特别高，允许一定程度的容错率，对通信过程中的通信速度的要求搞过通信质量，此时可以选择UDP协议实现。



#### 16、请写入你对进程和线程的理解，以及他们的区别？

* 进程：进程是操作系统资源分配的最小单位，进程具备独立的数据空间。进程与进程之间是相互独立的，不会互相影响，由操作系统负责调度。
* 线程：线程不能独立执行，必须依存于进程中。一个进程中至少有一个主线程。同时，一个进程中可以有多个线程进行任务处理，即多线程。
* 进程的切换是由操作系统管理，消耗资源大，效率低；线程的管理在进程应用程序内部实现，效率比进程高。



#### 17、请简述sleep和wait有什么区别？

* wait方法在超类Object中定义，sleep方法属于Thread类。
* 使用sleep时可能发生异常，需要异常处理，wait属于object中的方法，不需要处理异常
* sleep方法：程序只会让出cpu资源，但不会释放对象**锁**。
* wait方法：程序让出cpu资源，同时释放占用的**锁**。



#### 18、在程序中有声明周期的概念，程序的声明周期即代表着程序的生老病死。根据你所学的java知识，请简述线程的声明周期和其主要的状态。

* 新建(New) :创建后尚未启动的线程的状态
* 可运行(Runnable):就绪和运行两种状态统称为运行中
* 阻塞(Blocked):等待获取排它锁
* 无限期等待(Waiting): 阻塞是被动的，等待是主动的，不会被分配CPU执行时间，需要显式被唤醒
  * 进入无限期等待：Object.wait方法，使用Object.notify或者Object.notifyAll方法唤醒等待
* 有期限的等待（Timed Waiting)：在一定时间后会由系统自动唤醒
  * 进入有期限等待：Thread.sleep方法，到时间后会退出等待；或者调用Object.notify或者notifyAll方法
* 线程的声明周期状态中，从新建状态到可运行状态是不可逆的，同理处于运行状态的线程的方法执行完毕后会退出线程的执行，线程进入消亡状态。



#### 19、请简述在Java中存在的四种引用，并简单的做解释？

Java中存在强软弱虚四种类型的引用，四种不同类型的引用之间的区别主要体现在垃圾回收的不同机制和策略上。

* **强引用**

  一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。

* **软引用**

  在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。

* **弱引用**

  具有弱引用的对象拥有的生命周期更短暂，当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。

* **虚引用**

  虚的意思即为形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。



#### 20、写入你所知道的Java中实现多态的方法？（三种即可）

在java中实现多态主要有三种方式：

① 声明一个接口，然后定义类实现接口

② 定义子类继承另外一个父类实现继承，并在子类中根据需要重写方法

③ 在同一个类中对方法进行重载。



#### 21、在Java中，集合框架是非常重要的实现，请总结出Java集合框架的基础框架有哪些？

* Collection为集合框架的根接口。
* List是一个可以存储数据的列表集合，该集合中存储数据时数据是有序的，元素可以重复，且该集合的长度是可变的。
* Map是用于描述一组数据之间关系的集合，使用key作为关系映射的关键字，value作为映射关键的结果。在一个map集合中，key不能重复，value可以重复。
* Set是一个存储非重复数据的集合。
* 除此之外，还有Queue、Dequeue等也是Java集合框架的组成部分。



#### 22、请写出5个常用的List集合的API方法?

* int size()：集合元素的个数
* boolean add(o)：向集合中添加一个元素
* Object get(int)：获取某个位置上的元素
* boolean remove(o): 删除某个特定的元素
* boolean contains(o)：判断是否包含某个特定元素
* void clear()：将元素清除



#### 23、根据你的理解，ArrayList和LinkedList有什么区别？

ArrayList底层的实现是数组，可以随机访问；LinkedList底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。



#### 24、什么是JDBC，有什么作用？

JDBC的全称是Java DataBase Connection，也就是Java数据库连接，我们可以用它来操作关系型数据库。JDBC接口及相关类在java.sql包和javax.sql包里。我们可以用它来连接数据库，执行SQL查询，存储过程，并处理返回的结果。

JDBC接口让Java程序和JDBC驱动实现了松耦合，使得切换不同的数据库变得更加简单。



#### 25、JDBC中的Statement和PreparedStatement有什么联系和区别。

* 联系：Statement和PreparedStatement均是jdbc中用来执行数据SQL语句接口API。
* 区别：PreparedStatement是预编译的，可以将对应的SQL执行多次，并且PreparedStatement可以自动转移特殊字符，从而避免SQL注入。



#### 26、数据库事务是重要的概念，请问数据库事务中的ACID指的是什么？

* A是单词Atomic：原子性，事务中的操作，要么全做要么全不做，利用事务将多个操作的状态绑定在一起，全部执行成功才算事务成功，一个执行失败全都执行失败。
* C是单词Consistent：一致性，事务结束后系统状态应该是一样的。
* I是单词Isolated：隔离性，当出现并发执行时，各个事务之间是相互独立的。
* D是单词Durable：持久性，事务执行后对数据库的操作和改动是永久性的，无法撤销。



#### 27、在Java编程开发和实践中，操作数据库时常常会用到数据库连接池，根据你的了解和使用经验，请简述连接池有什么作用？

每次在创建数据库链接和断开数据库连接时，都会消耗较大的资源。

为了提高程序访问数据库的效率，提高程序整体的性能，在开发实践中常常会创建一定数量的链接，单独放在一个连接池中。程序执行过程中，如果需要数据库操作，直接从事先准备好的连接池中获取连接即可，从而避免了频繁创建连接和释放链接造成的资源占用。

连接池技术在Java开发实践过程中经常用到，比如在多线程项目中经常会用到线程池。



#### 28、Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？并对每一类举例JDK中具体的实现。

Java的IO集合中有以下几种流：

* 字节输入流：InputStream
  * FileInputStream
  * ByteArrayInputStream
* 字节输出流：OutputStream
  * FileOutputStream
  * ByteArrayOutputStream
* 字符输入流：Reader
  * FileReader
  * BufferedReader
* 字符输出流：Writer
  * FileWriter
  * BufferedWriter
* InputStreamReader：字节输入流转换为字符读取流的桥接流
* OutputStreamWriter：字节输出流转换为字符写入流的桥接流



#### 29、File是JDK中定义的文件及目录的API类，请写入你所熟悉的该类的API方法？

* boolean exists() : 判断文件或者目录是否存在
* boolean isDir()：判断是否是目录
* boolean isFile(): 判断该对象是否是文件
* String getAbsolutePath()： 获取当前对象的绝对路径
* boolean mkdir(): 创建一个目录
* boolean delete()：删除当前文件或者目录
* long length()：获取当前文件的内容的字节大小



#### 30、在编程实践中，经常会对数据及实例序列化操作。请解释什么是序列化。并根据所学知识，简述在Java中如何实现序列化操作？

序列化是只将内存中的数据写入到IO流中，并使之可以写入到文件中或者变成其他可以持久化存储的状态中，与序列化对应的是反序列化，即将文件或者其他持久化状态中的数据通过IO操作读取到内存中的过程。

在Java中，如果要实现某个类实例对象支持序列化操作，可以让该类实现Serializable接口或者Externalizable接口。



#### 31、java.lang包是Java中的最经常使用的一个包，尝试写出你经常使用的java.lang包中的几个类（至少5个）。

* String：字符串类
* Thread：线程类
* Math：数学及运算操作类
* StringBuffer：带有缓冲区的字符串操作类
* System：包含很多常见操作的类



#### 32、请写出String类中常见的对字符串的操作及其对应的API？（至少5个）

* 字符串长度：size()
* 字符串替换：repleace()
* 是否包含某个字符串：contains(string)
* 字符串查找：indexOf(int);
* 字符串去除空格：trim()
* 判断字符串是否为空：isEmpty()



#### 33、在Java中，异常处理机制是非常重要的设计，请简述Java中的error 和 exception 有什么区别？

error 表示系统级的错误和程序不必处理的异常，比如内存溢出，不可能指望程序能处理这样的情况； 

exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。



#### 34、请结合你的所学和你的实践经验，简述Java的异常处理机制？

Java 的异常处理是通过5个关键词来实现的：try、catch、throw、throws 和 finally。

① 首先，在编写程序时，对于可能出现的异常代码，可以用try来执行改段程序，如果出现异常，系统会抛出（throw）一个异常。

② 为了处理异常，我们可以通过它的类型来捕捉（catch）该异常，捕获到该异常以后，执行处理逻辑。

③ 最后，无论发生异常与否，java提供一个finally代码块，用于执行最后的代码逻辑。

④ 如果在程序中不想处理该异常，可以使用throws关键字将可能出现的异常抛出，留给其他调用的人处理。



#### 35、Java这一强大的编程语言，从发布至今一直保持旺盛的生命力。在具体的实践中，有很多经典的设计模式被创造和运用。请写出你经常使用的几种设计模式？（至少5种）

工厂模式

单例模式

代理模式

装饰模式

建造者模式

观察者模式



##### 36、单例模式是Java编程实践中最最经典的使用，请写出单例模式的两种常见的实现形式？

饿汉式单例：

```java
public class Singleton {  
    private Singleton(){}  
    private static Singleton instance = new Singleton();  
    public static Singleton getInstance(){  
        return instance;  
    }  
} 
```

懒汉式单例：

```java
public class Singleton {  
    private static Singleton instance = null;  
    private Singleton() {}  
    public static synchronized Singleton getInstance(){  
        if (instance==null) instance＝newSingleton();  
        return instance;  
    }  
}  
```

#### 37、在学习和工作过程中，你一定使用过工厂模式，请简述你对工厂模式的理解？

工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。



#### 38、在数据库使用过程中，经常使用索引，请解释什么是索引。并列举MySQL数据中支持的索引类型？

索引是对数据库表中一或多个列的值进行排序的结构，可以高效获取数据的一种数据结构。或者也可以将索引理解为，索引就是加快检索表中数据的方法。

MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引



#### 39、请解释数据库的乐观锁和悲观锁是什么？

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。

乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

* 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
* 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。



#### 40、代码题：假设现在有一个类Box，该类有两个字段，分别为width和height，均为int类型，该类可以序列化。请实现代码。

```java
public class Box implements Serializable{

    private int width;
    private int height;

    public Box(int width, int height) {
        this.width = width;
        this.height = height;
    }

    public int getWidth() {
        return width;
    }

    public void setWidth(int width) {
        this.width = width;
    }

    public int getHeight() {
        return height;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    @Override
    public String toString() {
        return "Child{" +
                "width=" + width +
                ", height=" + height +
                '}';
    }
}
```

